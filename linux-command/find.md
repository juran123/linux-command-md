## find ##

在指定目录下查找文件

### 补充说明 ###

Linux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间


###  语法

	find 搜索路径 [选项] 搜索内容

###  选项

    -amin<分钟>：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；
	-anewer<参考文件或目录>：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；
	-atime<24小时数>：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；
	-cmin<分钟>：查找在指定时间之时被更改过的文件或目录；
	-cnewer<参考文件或目录>查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
	-ctime<24小时数>：查找在指定时间之时被更改的文件或目录，单位以24小时计算；
	-daystart：从本日开始计算时间；
	-depth：从指定目录下最深层的子目录开始查找；
	-expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；
	-exec<执行指令>：假设find指令的回传值为True，就执行该指令；
	-false：将find指令的回传值皆设为False；
	-fls<列表文件>：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；
	-follow：排除符号连接；
	-fprint<列表文件>：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；
	-fprint0<列表文件>：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；
	-fprintf<列表文件><输出格式>：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；
	-fstype<文件系统类型>：只寻找该文件系统类型下的文件或目录；
	-gid<群组识别码>：查找符合指定之群组识别码的文件或目录；
	-group<群组名称>：查找符合指定之群组名称的文件或目录；
	-help或——help：在线帮助；
	-ilname<范本样式>：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；
	-iname<范本样式>：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；
	-inum<inode编号>：查找符合指定的inode编号的文件或目录；
	-ipath<范本样式>：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；
	-iregex<范本样式>：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；
	-links<连接数目>：查找符合指定的硬连接数目的文件或目录；
	-iname<范本样式>：指定字符串作为寻找符号连接的范本样式；
	-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；
	-maxdepth<目录层级>：设置最大目录层级；
	-mindepth<目录层级>：设置最小目录层级；
	-mmin<分钟>：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；
	-mount：此参数的效果和指定“-xdev”相同；
	-mtime<24小时数>：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；
	-name<范本样式>：指定字符串作为寻找文件或目录的范本样式；
	-newer<参考文件或目录>：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
	-nogroup：找出不属于本地主机群组识别码的文件或目录；
	-noleaf：不去考虑目录至少需拥有两个硬连接存在；
	-nouser：找出不属于本地主机用户识别码的文件或目录；
	-ok<执行指令>：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；
	-path<范本样式>：指定字符串作为寻找目录的范本样式；
	-perm<权限数值>：查找符合指定的权限数值的文件或目录；
	-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；
	-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；
	-printf<输出格式>：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；
	-prune：不寻找字符串作为寻找文件或目录的范本样式;
	-regex<范本样式>：指定字符串作为寻找文件或目录的范本样式；
	-size<文件大小>：查找符合指定的文件大小的文件；
	-true：将find指令的回传值皆设为True；
	-type<文件类型>：只寻找符合指定的文件类型的文件；
	-uid<用户识别码>：查找符合指定的用户识别码的文件或目录；
	-used<日数>：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；
	-user<拥有者名称>：查找符和指定的拥有者名称的文件或目录；
	-version或——version：显示版本信息；
	-xdev：将范围局限在先行的文件系统中；
	-xtype<文件类型>：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。

###  参数
第一个参数用来指定搜索路径，第二个参数用来指定搜索内容。

###  实例


### 1. 按照文件名搜索
	选项：
	-name: 按照文件名搜索；
	-iname: 按照文件名搜索，不区分文件名大小；
	-inum: 按照 inode 号搜索；
	
	文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。 
	可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。 
	不管当前路径是什么，如果想要在自己的根目录$HOME中查找文件名符合*.log的文件，
	
	1：在etc目录下査找文件名是pam.conf的文件
	# find /etc -name pam.conf

	2：使用~作为 'pathname'参数，波浪号~代表了你的$HOME目录。
	# find ~ -name "*.log" 

	3：想要在当前目录及子目录中查找所有的‘ *.log‘文件，可以用：
	# find . -name "*.log" 

	4：想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：
	# find . -name "[A-Z]*" 

	5：想要在/etc目录中查找文件名以host开头的文件，可以用：
	# find /etc -name "host*" 

	6：想要查找$HOME目录中的文件，可以用：
	# find ~ -name "*" 

	7：要想让系统高负荷运行，就从根目录开始查找所有的文件。
	# find / -name "*" 
	
	8：如果想在当前目录查找文件名以一个个小写字母开头，最后是4到9加上.log结束的文件：
	# find . -name "[a-z]*[4-9].log" -print

### 2. 按照文件大小搜索
	选项：
	-size[+-]大小：按照指定大小搜索文件

	这里的"+"的意思是搜索比指定大小还要大的文件，"-" 的意思是搜索比指定大小还要小的文件。
	
	可以按照文件长度来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。
	'b' 默认单位，如果单位为b或不写单位，则按照 512Byte搜索
	'c' 按照字节搜索
	'w' 按照双字节（中文）搜索
	'k' 按照KB单位搜索，必须是小写的k
	'M' 按照MB单位搜索，必须是大写的M
	'G' 按照GB单位搜索，必须是大写的G
	
	在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，
	因为这时使用块来计量更容易转换。
	
	1：在当前目录下查找文件长度等于389字节的文件
	#	find . -size 389c
	2：在当前目录下查找文件长度大于1k字节的文件
	#	find . -size +1k
	3：在当前目录下查找文件长度大于1M字节的文件
	#	find . -size +1M
	#	find . -size +1000000c
	4：在/home/apache目录下查找文件长度恰好为100字节的文件:
	#	find /home/apache -size 100c
	5：在当前目录下查找长度超过10块的文件（一块等于512字节）
	#	find . -size +10
	
### 3.  按照修改时间搜索

	选项：
	-atime [+-]时间: 按照文件访问时间搜索
	-mtime [+-]时间: 按照文改修改时间搜索
	-ctime [+-]时间: 按照文件改变时间搜索
	这里用 mtime 数据修改时间来举例，解释 "[+-]"时间的含义。
	-5：代表5天内修改的文件。
	5：代表前5~6天那一天修改的文件。
	+5：代表6天前修改的文件。
	
	如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。如果系统突然没有可用空间了，
	很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。

	用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。

	1：希望在系统根目录下查找更改时间在5日以内的文件，可以用：
	# find / -mtime -5 

	2：为了在/var/adm目录下查找更改时间在3日以前的文件，可以用:
	# find /var/adm -mtime +3 

### 4. 按照文件类型搜索
	选项:
	-type d：查找目录
	-type f：查找普通文件
	-type l：查找软链接文件
	
	1：在/etc目录下查找所有的目录
	# find /etc -type d   

	2：在当前目录下查找除目录以外的所有类型的文件
	# find . ! -type d  

	3：在/etc目录下查找所有的符号链接文件
	# find /etc -type l 
	

	
### 5. 按照权限搜索

	选项：
	-perm 权限模式：査找文件权限刚好等于"权限模式"的文件
	-perm -权限模式：査找文件权限全部包含"权限模式"的文件
	-perm +权限模式：査找文件权限包含"权限模式"的任意一个权限的文件

	建立几个测试文件
	# cd test/
	# touch test{1..4}
	# chmod 755 testl
	# chmod 444 test2
	# chmod 600 test3
	# chmod 200 test4

	1：-perm权限模式,代表査找的权限必须和指定的权限模式一模一样才可以找到。
	# find . -perm 444
	2："-perm-权限模式",代表的是文件的权限必须全部包含搜索命令指定的权限模式才可以找到。
	# find .-perm -200
	
	按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用十进制的权限表示法。
	如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：
	
	find . -perm 755 
	find -perm，根据文件的权限来查找文件，有三种形式：
	find -perm mode
	find -perm -mode
	find -perm +mode
	
	那么这三者之间有什么区别呢？解释之前首先得简单说一下linux中文件权限位的概念。在linux中文件或目录有三者
	权限r,w,x，代表的含义分别是读、写、可执行。而一个文件或目录的属性中又包括所属用户u、所属组g、其他o三个
	部分的属性，分别表示所属用户、所属组、其他用户对这个文件所拥有的权限。看起来大概是这个样子：
	所属用户 所属组 其他
	rwx rwx rwx
	
	用户在其拥有权限的位上设置1，没有权限的位设置0。如果将每个部分的这些权限位看成二进制数，每个部分可以用
	3位二进制数表示，最大值为7(2^3-1)，表示可读、可写、可执行。严格的来说，文件权限除了r、w、x以外还有
	setuid,setgid权限，等下再解释。
	好了，有了权限位的基础，那么再来看find -perm mode。mode是三个数字表示的，每个数字最大值是7（原因前
	面解释过了）。
	find -perm mode ， 表示严格匹配，也就是你的文件权限位转换成对应的十进制数字与mode一模一样，那么匹配
	成功，需要注意的是如果mode给的数字不足3位，那么前面自动添0(严格的说是不足4位，原因就是前面所说的
	setuid,setgid，稍后解释)
	
	find -perm -mode ， 表示mode中转换成二进制的1在文件权限位里面必须匹配，比如mode=644那么转换成二进
	制为110 100 100，而被查找的文件的权限位也可以被转换成一个二进制数，两者在位上为1的部分必须完全匹配，
	而0则不管。例如被查找的文件的权限为转换成二进制数是111 111 111那么这个比如被匹配，而假如是100 100 100
	那么则不会匹配。所以这个'-'的作用归结起来就是匹配比mode权限更充足的文件(找不到什么词语来形容了)
	
	find -perm +mode ， 与 -mode的区别是+mode只需其中的任意一个1的部分被匹配，-mode是所有1的部分都必须
	被匹配，同样+mode也不管0位。
	
	现在来解释setuid,setgid，setuid权限是用来使其他用户可以“越权”执行你的命令，而本质上的实现就是在权限
	检查的时候，在进程的的有效UID里面保存了这个其他用户的UID,所以权限得验证通过，这些权限用一个新的3位二进制数表示，
	有4,2,1三种值，4表示有setuid权限，2表示有setgid权限，1表示有粘着位(t)权限（粘着位权限最典型
	的例子是/tmp，每个用户可以在里面创建、更新、删除自己创建(文件所属用户是自己)的文件，而不能更改别人的文件）。

### 6.  按照所有者和所属组搜索
	
	选项：
	-uid 用户 ID:按照用户 ID 査找所有者是指定 ID 的文件
	-gid 组 ID:按照用户组 ID 査找所属组是指定 ID 的文件
	-user 用户名：按照用户名査找所有者是指定用户的文件
	-group 组名：按照组名査找所属组是指定用户组的文件
	-nouser：査找没有所有者的文件
	
	1：在$HOME目录中查找文件属主为hc的文件
	# find ~ -user hc
	
	1：在/etc目录下查找文件属主为hc的文件:
	# find /etc -user hc 
	
	2：为了查找属主帐户已经被删除的文件，可以使用-nouser选项。在/home目录下查找所有的这类文件
	# find /home -nouser
	说明：这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-nouser选项时，不必给出用户名；
	 find命令能够为你完成相应的工作。

	3：就像user和nouser选项一样，针对文件所属于的用户组，find命令也具有同样的选项，
	为了在/apps目录下查找属于gem用户组的文件，可以用：
	# find /apps -group gem
	
	4：要查找没有有效所属用户组的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件:
	# find / -nogroup

### 7. prune选项
查找时忽略指定目录，是要使用-prune选项，但实际上最重要的还是要和path配合。-prune的意义是，当路径字串匹配了path中指定的目录时 候，find命令不进入这个目录查找，所以这个选项使用的关键，还是在path选项上的使用，也就是path选项和其他选项的配合使用，才能最后确定最终 结果。而path，实际上是对路径字串的一个字符匹配，但也并不仅仅只匹配于目录，文件同样可以被匹配，譬如存在一个目录结构。

	./01.txt
	./02.txt
	./03.txt
	./aaa
	./aaa/04.txt
	./aaa/05.txt


	如果加上-prune:
	
	# find . -path "./aaa*" -prune -print
	./aaa
	
	因为加入了-prune，在匹配这个目录同时禁止进入到这个目录下搜索，于是也就是我们所需要的不进入某个目录查找。
	
	但如何配合其他选项来使用-path 以及-prune呢？以-name为例，下面对于配合使用方法进行一下演示。
	
	我们先来看看纯粹的-name和-path配合使用是什么效果：
	
	# find -name "*.txt" -path "./aaa" -print
	这个命令也相当于
	# find -name "*.txt" -a -path "./aaa" -print

### 8. 查找比某个文件新或旧的文件：
	如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项。
	
	它的一般形式为：
	newest_file_name ! oldest_file_name  
	其中，！是逻辑非符号。
	
	1.查找更改时间比文件log1新但比文件log3旧的文件
	# find -newer log1  ! -newer log3

	2.查找当前目录下更改时间在比log2文件新的文件
	# find . -newer log2  -print





### 9. 使用depth选项
	在使用find命令时，可能希望先匹配所有的文件，再在子目录中查找。使用depth选项就可以使find命令这样做。
	这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，
	其次再备份子目录中的文件。
	
	find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。
	#	find / -name "CON.FILE" -depth -print
	
	它将首先匹配所有的文件然后再进入子目录中查找

### 10. find命令之exec

-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。

{} 花括号代表前面find查找出来的文件名。

使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。 exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。

	1. 查找当前目录下的文件，并对查找结果执行ls -l 命令
	# find . -type f -exec ls -l {} \;
		
	2. 查找当前目录下，24小时内更改过的文件，并进行删除操作（慎用！！！，删除没有提示）
	# find -type f -mtime -1 -exec rm {} \;
	在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如mv或rm命令时，
	可以使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。
	
	3. 查找当前目录下文件名以.log结尾且24小时内更改过的文件，并进行安全删除操作（即删除前会进行询问）
	# find -name "*.log" -type f  -mtime -1 -ok rm {} \;
	-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，
	在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 
	
	4. 查找当前目录下的以.log结尾的文件或目录，并移动到test目录下
	# find -name "*.log" -exec mv {} test \;
